/*
	Pseudo-CRT emulation shader (and some other stuff).
	(C)2013 Marisa Kirisame, UnSX Team
	Some parts cobbled together from original effect.txt by Boris, and
	random algorithms taken from the internet.
	Released under the WTFPL.
*/

/*
   The original code for some sections (mainly the curvature one) made me wish
   I could choke the original authors through standard TCP/IP.
*/

/* PS: HLSL is disgusting. I prefer GLSL, or even pure C software shaders. */

/* Borders are blurred */
#define EBORDERBLUR
/* border shine blur sampling range */
float blursamp = 1.5;
/* blend power of blur */
float blurpow = 28.0;
/* falloff curve of blur towards center of screen */
float blurcurve = 2.2;
/* blur falloff radius */
float blurradius = 0.56;

/* Crossblur modified from Uboa Engine */
#define ECROSSBLUR
/* crossblur sampling range */
float cblursamp = 0.3;

/* Soft grain */
#define EGRAIN
/* soft grain speed */
float nf = 0.02;
/* soft grain intensity */
float ni = 0.01;
/* soft grain saturation */
float ns = 0.15;

/* Block graphics filter with palette reduction */
#define EBLOCKGFX
/* emulated resolution for block graphics (0 or less for real resolution) */
float2 bres = float2(320,200);
/* do not scale */
bool bnoscale = false;
/* perform aspect ratio correction on emulated screen (ignored if no scale) */
bool bratio = true;
/* extra border factor (negative values for overscan) */
float bborderf = 0.05;
/*
   palette type for block graphics:
    0: 64-color AOS
    1: 6bpc
    2: CGA
    3: 16-bit RGB565
   other values disable palette reduction
*/
int paltype = 0;
/* Use AOS CGA colors rather than standard CGA */
#define AOSCGA

/* Cheap dot matrix filter */
#define EDOTMATRIX
/* blend factor for dot matrix */
float dotblend = 0.4;
/* subpixel size in pixels */
int dotsize = 1;

/* Dirty screen effect (static noise) */
#define EDIRT
/* dirt amount */
float dirtfactor = 0.08;

/* Use CRT curvature shader */
#define ECRT
/* chromatic aberration on CRT: fancy effect that isn't really realistic */
float chromaab = 0.015;
/* curvature lens zoom (0.5 = none) */
float lenszoom = 0.53;
/* curvature lens distortion */
float lensdist = 0.1;
/* not sure what this does */
float lensdistc = 0.1;

/*
   +------------------------------+
   |User-tweakable stuff ends here|
   +------------------------------+
*/

/* do not touch this! */
#define E_SHADER_3_0

/* standard stuff */
float tempF1;
float tempF2;
float tempF3;
float tempF4;
float tempF5;
float tempF6;
float tempF7;
float tempF8;
float tempF9;
float tempF0;
float4 Timer;
float4 ScreenSize;

/* samplers and textures */
texture2D texColor;
texture texNoise;
sampler2D SamplerColor = sampler_state
{
	Texture	= <texColor>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = NONE;
	AddressU = Clamp;
	AddressV = Clamp;
	SRGBTexture = FALSE;
	MaxMipLevel = 0;
	MipMapLodBias = 0;
};
sampler2D SamplerNoise = sampler_state
{
	Texture = <texNoise>;
	MinFilter = POINT;
	MagFilter = POINT;
	MipFilter = NONE;
	AddressU = Wrap;
	AddressV = Wrap;
	SRGBTexture = FALSE;
	MaxMipLevel = 0;
	MipMapLodBias = 0;
};

/* whatever */
struct VS_OUTPUT_POST
{
	float4 vpos : POSITION;
	float2 txcoord : TEXCOORD0;
};
struct VS_INPUT_POST
{
	float3 pos : POSITION;
	float2 txcoord : TEXCOORD0;
};

/* Shader routines */

VS_OUTPUT_POST VS_Process(VS_INPUT_POST IN)
{
	VS_OUTPUT_POST OUT;
	float4 pos = float4(IN.pos.x,IN.pos.y,IN.pos.z,1);
	OUT.vpos = pos;
	OUT.txcoord.xy = IN.txcoord.xy;
	return OUT;
}

float4 PS_ProcessBlur(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef EBORDERBLUR
	float4 origcolor = res;
	float4 tcol = float4(0,0,0,0);
	float2 bresl = float2(ScreenSize.x,ScreenSize.x*ScreenSize.w);
	float4 bof = float4(1.0/bresl.x,1.0/bresl.y,0,0)*blursamp;
	int i, j;
	for ( i=-2; i<3; i++ )
		for( j=-2; j<3; j++ )
			tcol += tex2Dlod(SamplerColor,
				coord+float4(i,j,0,0)*bof);
	tcol *= 0.04;
	float2 uv = (IN.txcoord.xy-0.5)*blurradius;
	float vig = pow(saturate(dot(uv.xy,uv.xy)),blurcurve);
	res.xyz = lerp(origcolor.xyz,tcol.xyz,vig*blurpow);
#endif
	return res;
}

float4 PS_ProcessDirt(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef EDIRT
	float gray = (res.r+res.g+res.b)/3.0;
	float4 ncol = tex2Dlod(SamplerNoise, coord*16+gray);
	res = lerp(res,(ncol.r+1)*res,dirtfactor*saturate(1-gray*0.5));
#endif
	return res;
}

float4 PS_ProcessCurve(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef ECRT
	float4 tcol = res;
	float3 eta = float3(1+chromaab*0.9,1+chromaab*0.6,1+chromaab*0.3);
	float2 center = float2(coord.x-0.5,coord.y-0.5);
	float zfact = 1.0/lenszoom;
	float r2 = center.x*center.x+center.y*center.y;
	float f = 0;
	if( lensdistc == 0.0)
		f = 1+r2*lensdist;
	else
		f = 1+r2*(lensdist+lensdistc*sqrt(r2));
	float x = f*zfact*center.x+0.5;
	float y = f*zfact*center.y+0.5;
	float2 rcoord = (f*eta.r)*zfact*(center.xy*0.5)+0.5;
	float2 gcoord = (f*eta.g)*zfact*(center.xy*0.5)+0.5;
	float2 bcoord = (f*eta.b)*zfact*(center.xy*0.5)+0.5;
	float4 idist = float4(tex2D(SamplerColor,rcoord).r,
		tex2D(SamplerColor,gcoord).g,
		tex2D(SamplerColor,bcoord).b,
		tex2D(SamplerColor,float2(x,y)).a);
	/* clamp (currently hard, will add softening later */
	float clampval = 0.01;
	if ( rcoord.x < clampval || rcoord.x >= 1-clampval
		|| rcoord.y < clampval || rcoord.y >= 1-clampval )
		idist.r *= 0;
	if ( gcoord.x < clampval || gcoord.x >= 1-clampval
		|| gcoord.y < clampval || gcoord.y >= 1-clampval )
		idist.g *= 0;
	if ( bcoord.x < clampval || bcoord.x >= 1-clampval
		|| bcoord.y < clampval || bcoord.y >= 1-clampval )
		idist.b *= 0;

	res.rgb = idist.rgb;
#endif
	return res;
}

float4 PS_ProcessCrossblur( VS_OUTPUT_POST IN, float2 vPos : VPOS ) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef ECROSSBLUR
	float2 bresl = float2(ScreenSize.x,ScreenSize.x*ScreenSize.w);
	float4 bof = float4(1.0/bresl.x,1.0/bresl.y,0,0)*cblursamp;
	float factor[4] = {0.3,0.2,0.1,0.05};
	int i, j;
	res *= 0;
	/* I'm going to hell for this ugly staircase code */
	for ( i=-3; i<4; i++ )
		for ( j=-3; j<4; j++ )
			res += factor[abs(i)]*factor[abs(j)]
				*tex2Dlod(SamplerColor,
					coord+float4(i,j,0,0)*bof);
#endif
	return res;
}

float4 PS_ProcessBlock( VS_OUTPUT_POST IN, float2 vPos : VPOS ) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef EBLOCKGFX
	float4 rresl = float4(ScreenSize.x,ScreenSize.x*ScreenSize.w,1,1);
	float4 bresl;
	if ( bres.x <= 0 || bres.y <= 0 )
		bresl = rresl;
	else
		bresl = float4(bres.x,bres.y,1,1);
	float4 ncoord = floor(coord*bresl)/bresl;
	float4 rratio = rresl/bresl;
	if ( !bnoscale )
	{
		if ( bratio )
			rratio /= min(rratio.x,rratio.y);
		else
			rratio /= rratio;
	}
	rratio *= 1+bborderf;
	ncoord = ((ncoord-float4(0.5,0.5,0,0))*rratio)+float4(0.5,0.5,0,0);
	float4 tcol = tex2Dlod(SamplerColor,ncoord);
	/* clamp */
	if ( ncoord.x < 0 || ncoord.x >= 1 || ncoord.y < 0 || ncoord.y >= 1 )
		tcol *= 0;
	/* 64-color (4bpc) AOS EGA region */
	if ( paltype == 0 )
	{
		/* dither */
		bool evx = (coord.x*bresl.x)%2 < 1;
		bool evy = (coord.y*bresl.y)%2 < 1;
		if ( evx != evy )
			tcol = tcol+float4(1,1,1,0)*0.01;
		else
			tcol = tcol-float4(1,1,1,0)*0.01;
		/* truncate */
		res.rgb = trunc(tcol.rgb*16.0)/16.0;
		/* additional brightness bump */
		res = res+float4(1,1,1,0)*0.02;
	}
	/* 6bpc */
	else if ( paltype == 1 )
	{
		/* dither */
		bool evx = (coord.x*bresl.x)%2 < 1;
		bool evy = (coord.y*bresl.y)%2 < 1;
		if ( evx != evy )
			tcol = tcol+float4(1,1,1,0)*0.01;
		else
			tcol = tcol-float4(1,1,1,0)*0.01;
		/* truncate */
		res.rgb = trunc(tcol.rgb*64.0)/64.0;
		/* additional brightness bump */
		res = res+float4(1,1,1,0)*0.02;
	}
	/* CGA palette */
	else if ( paltype == 2 )
	{
		float4 dac;
		/* brighten shadows */
		tcol.rgb = pow(tcol.rgb,0.5);
		/* dither */
		bool evx = (coord.x*bresl.x)%2 < 1;
		bool evy = (coord.y*bresl.y)%2 < 1;
		if ( evx != evy )
			tcol = tcol+float4(1,1,1,0)*0.01;
		else
			tcol = tcol-float4(1,1,1,0)*0.01;
		/* additional brightness bump */
		tcol = tcol-float4(1,1,1,0)*0.01;
		/* oversaturate components */
		dac.a = (tcol.r+tcol.g+tcol.b)/3.0;
		dac.r = dac.a+(tcol.r-dac.a)*3.0;
		dac.g = dac.a+(tcol.g-dac.a)*3.0;
		dac.b = dac.a+(tcol.b-dac.a)*3.0;
		/* color lookup */
	#ifdef AOSCGA
		float3 cgapal[16] =
		{
			float3(0.000000,0.000000,0.000000),
			float3(0.500000,0.000000,0.000000),
			float3(0.125000,0.500000,0.000000),
			float3(0.625000,0.250000,0.125000),
			float3(0.000000,0.125000,0.343750),
			float3(0.234375,0.000000,0.343750),
			float3(0.062500,0.625000,0.812500),
			float3(0.343750,0.343750,0.343750),
			float3(0.125000,0.125000,0.125000),
			float3(1.000000,0.250000,0.250000),
			float3(0.281250,1.000000,0.250000),
			float3(1.000000,0.875000,0.234375),
			float3(0.187500,0.500000,1.000000),
			float3(0.750000,0.187500,1.000000),
			float3(0.281250,0.875000,1.000000),
			float3(1.000000,1.000000,1.000000),
		};
	#else
		float3 cgapal[16] =
		{
			float3(0.000,0.000,0.000),
			float3(0.333,0.000,0.000),
			float3(0.000,0.333,0.000),
			float3(0.333,0.333,0.000),
			float3(0.000,0.000,0.333),
			float3(0.333,0.000,0.333),
			float3(0.000,0.333,0.333),
			float3(0.666,0.666,0.666),
			float3(0.333,0.333,0.333),
			float3(1.000,0.333,0.333),
			float3(0.333,1.000,0.333),
			float3(1.000,1.000,0.333),
			float3(0.333,0.333,1.000),
			float3(1.000,0.333,1.000),
			float3(0.333,1.000,1.000),
			float3(1.000,1.000,1.000),
		};
	#endif
		float dist = 2.0;
		int idx = 0;
		for ( int i=0; i<16; i++ )
		{
			if ( distance(dac.rgb,cgapal[i]) < dist )
			{
				idx = i;
				dist = distance(dac.rgb,cgapal[i]);
			}
		}
		res.rgb = cgapal[idx];
		/* additional brightness bump */
		res = res+float4(1,1,1,0)*0.02;
	}
	/* RGB565 */
	else if ( paltype == 3 )
	{
		/* dither */
		bool evx = (coord.x*bresl.x)%2 < 1;
		bool evy = (coord.y*bresl.y)%2 < 1;
		if ( evx != evy )
			tcol = tcol+float4(1,1,1,0)*0.01;
		else
			tcol = tcol-float4(1,1,1,0)*0.01;
		/* truncate */
		res.r = trunc(tcol.r*32.0)/32.0;
		res.g = trunc(tcol.g*64.0)/64.0;
		res.b = trunc(tcol.b*32.0)/32.0;
		/* additional brightness bump */
		res = res+float4(1,1,1,0)*0.02;
	}
#endif
	return res;
}

float4 PS_ProcessDotmatrix( VS_OUTPUT_POST IN, float2 vPos : VPOS ) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef EDOTMATRIX
	/* number of dots */
	float4 bresl = float4(ScreenSize.x,ScreenSize.x*ScreenSize.w,1,1);
	bresl.xy *= 1.0/dotsize;
	/* RGBI dot luminance values */
	float4 dac = float4(res.r*0.5,res.g*0.5,res.b*0.5,
		(res.r+res.g+res.b)/6.0);
	float3 tcol;
	/* 2x2 matrix */
	if ( ((coord.x*bresl.x)%2 < 1) && ((coord.y*bresl.y)%2 < 1) )
		tcol.rgb = float3(dac.r,0,0);
	else if ( ((coord.x*bresl.x)%2 >= 0) && ((coord.y*bresl.y)%2 < 1) )
		tcol.rgb = float3(0,dac.g,0);
	else if ( ((coord.x*bresl.x)%2 < 1) && ((coord.y*bresl.y)%2 >= 0) )
		tcol.rgb = float3(0,0,dac.b);
	else
		tcol.rgb = float3(dac.a,dac.a,dac.a);
	/* blend in */
	res.rgb = res.rgb*(1-dotblend)+tcol.rgb*dotblend;
	/* screen boundary */
	float2 bfact = float2(0.0,0.0);
	float2 bounds = float2(bfact.x/bresl.x,bfact.y/bresl.y);
	if ( (coord.x < bounds.x) || (coord.x > 1-bounds.x)
		|| (coord.y < bounds.y) || (coord.y > 1-bounds.y) )
		res *= 0;
#endif
	return res;
}

/* pseudorandom number generator */
float random( in float2 uv )
{
	float2 n = frac(sin(dot(uv,float2(12.9898,78.233)*2.0))*43758.5453);
	return abs(n.x+n.y)*0.5;
}

float4 PS_ProcessGrain( VS_OUTPUT_POST IN, float2 vPos : VPOS ) : COLOR
{
	float4 coord = float4(IN.txcoord.x,IN.txcoord.y,0,0);
	float4 res = tex2Dlod(SamplerColor,coord);
#ifdef EGRAIN
	float ts = Timer.x*nf;
	float2 tcs = coord.xy;
	float2 s1 = tcs+float2(0,ts);
	float2 s2 = tcs+float2(ts,0);
	float2 s3 = tcs+float2(ts,ts);
	float n1 = random(s1);
	float n2 = random(s2);
	float n3 = random(s3);
	float n4 = (n1+n2+n3)/3;
	float3 ng = float3(n4,n4,n4);
	float3 nc = float3(n1,n2,n3);
	res.rgb += lerp(ng,nc,ns)*ni-0.5*ni;
#endif
	return res;
}

technique PostProcess
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessBlur();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess2
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessCrossblur();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess3
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessGrain();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess4
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessBlock();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess5
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessDotmatrix();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess6
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessDirt();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}

technique PostProcess7
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_Process();
		PixelShader = compile ps_3_0 PS_ProcessCurve();
		DitherEnable = FALSE;
		ZEnable = FALSE;
		CullMode = NONE;
		ALPHATESTENABLE = FALSE;
		SEPARATEALPHABLENDENABLE = FALSE;
		AlphaBlendEnable = FALSE;
		StencilEnable = FALSE;
		FogEnable = FALSE;
		SRGBWRITEENABLE = FALSE;
	}
}
